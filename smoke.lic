=begin
  smoke:
    container: smoking jacket
    pipe: glitvire pipe
    lighter: lava drake
    blade: serrated parazonium
    time_between_exhales: 3
    clean_list_of_mastered: true
    smoke_images:
    - deer
    - tart
=end

custom_require.call(%w[common common-items events])

class Smoke
  def initialize
    Flags.add('new-cig', 'That was the last of your', 'goes out and crumbles away'); Flags['new-cig'] = true
    @full_image_list = ['deer', 'dragon', 'rabbit', 'pixie', 'kitten', 'troll', 'horse', 'paladin', 'whip', 'cloak', 'stump', 'fleas', 'daisies', 'unicorn', 'rams', 'bandit', 'ship', 'grave', 'fish', 'web', 'phoenix', 'bracelet', 'skeleton', 'tart', 'almanac', 'dartboard']
    UserVars.smoke_images_known ||= @full_image_list
    UserVars.smoke_images_mastered ||= []
    arg_definitions = [
      [
        { name: 'cigar', regex: /\w+?\s?cigar|cigar/i, variable: true, description: 'Cigar noun.' },
        { name: 'image', options: UserVars.smoke_images_known, optional: true, description: 'Option to select a particular image out of your known images' },
        { name: 'repeat', regex: /\d+/, optional: true, description: 'Smoke this many pieces of tobacco' },
        { name: 'until_out', regex: /until_out/i, optional: true, description: 'Smoke until out of tobacco' }
      ],
      [
        { name: 'pipe', regex: /pipe/i, description: 'Uses the pipe defined in your yaml settings' },
        { name: 'image', options: UserVars.smoke_images_known, optional: true, description: 'Option to select a particular image out of your known images' },
        { name: 'repeat', regex: /\d+/, optional: true, description: 'Smoke this many pieces of tobacco' },
        { name: 'until_out', regex: /until_out/i, optional: true, description: 'Smoke until out of tobacco' }
      ],
      [
        { name: 'image', regex: /\w+/i, variable: true, description: 'Smoke image to learn, can be an ARRAY, will random one.' },
        { name: 'cigar', regex: /\w+/i, variable: true, description: 'Cigar noun.' },
        { name: 'container', regex: /\w+/i, variable: true, description: "Cigar's container." },
        { name: 'lighter', regex: /\w+/i, variable: true, description: "Lighter's noun." }
      ],
      [
        { name: 'smoke', regex: /cigar|pipe/i, description: 'smoke utensil to light' },
        { name: 'light_only', regex: /light_only/i, description: 'lights the provided smoke utensil' }
      ],
      [
        { name: 'reset_known', regex: /reset_known/i, description: 'Reset list of known smoke images, used after learning one or more new images' }
      ]
    ]

    args            = parse_args(arg_definitions)
    @smoke_settings = get_settings.smoke
    @equipmanager   = EquipmentManager.new
    images          = args.image || @smoke_settings['smoke_images'] || UserVars.smoke_images_known - UserVars.smoke_images_mastered
    @bag            = @smoke_settings['container']
    @pipe           = @smoke_settings['pipe']
    @lighter        = @smoke_settings['lighter']
    @blade          = @equipmanager.items.find { |gear| gear.short_regex =~ @smoke_settings['blade'] || gear.name =~ /\b#{@smoke_settings['blade']}\b/i }
    @cigar          = args.cigar
    @time_between   = @smoke_settings['time_between_exhales'] || 1

    quick_light(args.smoke) if args.light_only
    reset_known if args.reset_known

    unless args.image || UserVars.smoke_images_known.size == UserVars.smoke_images_mastered.size
      images = check_images(images)
      if images.empty?
        DRC.message("No valid images selected")
        exit
      end
    end
    DRC.message("Images to train: #{images.to_a.join(' ')}")

    if args.until_out
      smoke_loop(images.to_a, 99)
    elsif args.repeat
      smoke_loop(images.to_a, args.repeat.to_i)
    else
      smoke_loop(images.to_a, 1)
    end
  end

  def smoke_loop(images, number)
    DRCT.walk_to(@smoke_settings['smoke_room'])
    number.times do
      if @cigar && Flags['new-cig']
        Flags.reset('new-cig')
        break unless DRCI.get_item_if_not_held?(@cigar, @bag)

        light_tobacco(@cigar)
        smoker = @cigar
      elsif @pipe && Flags['new-cig']
        Flags.reset('new-cig')
        break unless load_pipe

        smoker = @pipe
      end
      smoke(images, smoker) until Flags['new-cig']
      images = check_images(images) if @smoke_settings['clean_list_of_mastered']
    end
    DRCI.put_away_item?(@pipe, @bag) if DRCI.in_hands?(@pipe)
    DRC.message("Smoker Complete!")
  end

  def load_pipe
    DRCI.get_item_if_not_held?(@pipe, @bag)
    contents = DRC.bput("look in my #{@pipe}", /^In the .* you see some .*/, /^There is nothing in there/)
    case contents
    when /burning/
      return true
    when /There is nothing/
      DRCI.get_item?('tobacco', @bag)
      DRCI.put_away_item?('tobacco', @pipe)
    end
    light_tobacco("tobacco in pipe")
  end

  def quick_light(smoke)
    case smoke
    when /pipe/
      load_pipe
      exit
    when /cigar/
      exit unless DRCI.get_item_if_not_held?(smoke, @bag)
      light_tobacco(smoke)
      exit
    end
  end

  def light_tobacco(target) # loaded pipe or cigar in hand, ends with either in hand, ready to rip
    if DRStats.warrior_mage?
      DRC.bput("prep c b t", /^You are now prepared/)
      DRC.bput("gesture #{target}", /^You touch/, /^That's already burning/)
    elsif @lighter
      unless DRCI.get_item?(@lighter)
        DRC.message("#{@lighter} appears to be awol, going to try flint and steel")
        @lighter = false
        return light_tobacco(target)
      end
      DRC.bput("point my #{@lighter} at #{target}", /making the .* quickly catch fire/, /^That's already burning/)
      DRCI.put_away_item?(@lighter, @bag)
    else # flint
      unless DRCI.get_item?("flint")
        DRC.message("Missing flint, scoot to your local shop and pick some up, every adventurer should have flint and steel")
        DRCI.put_away_item(DRC.right_hand, @bag)
        exit
      end
      DRCI.lower_item?(target.split.last)
      @equipmanager.get_item?(@blade)
      DRC.bput("light #{target} with my flint", /^Roundtime/, /^That's already burning/)
      DRCI.put_away_item?("flint", @bag)
      @equipmanager.return_held_gear
      DRCI.lift?
    end
  end

  def exhale_smoke(image)
    if /untrained/ =~ DRC.bput("exhale line #{image}", /^Roundtime/, /^You are untrained in the ways of making that image./)
      fput 'exhale ring'
    end
  end

  def inhale(image, smoker)
    if /out of your lungs first/ =~ DRC.bput("inhale my #{smoker}", /^You take/, /out of your lungs first/)
      exhale_smoke(image, true)
      return inhale(image, smoker)
    end
  end

  def smoke(images, smoker)
    # pull a random image from our list of images
    image = images.sample
    inhale(image, smoker)
    pause 1
    exhale_smoke(image)
    waitrt?
    pause @time_between
  end

  def reset_known
    # Resetting our known images to the master list
    UserVars.smoke_images_known = @full_image_list
    # and our mastered images to an empty list
    UserVars.smoke_images_mastered = []
    # Then cleaning out images we don't know, getting a list of images we've mastered
    # and providing a list of images to train
    DRC.message("New Training List: #{check_images(@full_image_list).join(' ')}")
    exit
  end

  def check_images(images)
    # Here we're returning IF the provided list of images is identical to our known image size, and the follow-on comparison suggests we've mastered everything we know.
    return images if images.size == UserVars.smoke_images_known.size && UserVars.smoke_images_known.size == UserVars.smoke_images_mastered.size

    smoke_list = []
    fput 'smoke list'
    loop do
      line = get
      break if line =~ /Total images known/ # last line after smoke list
      break if line =~ /You don't know any smoke images/ # last line of empty smoke list
      next if line.include?('IMAGE - SKILL') # topline that would normally match

      smoke_list << line.scan(/\w+\s-\s\w+\*?/) # grabbing lines: "<image> - <mastery level>       <image> - <mastery level>        <image> - <mastery level>"
    end
    smoke_list.flatten!
    # This draws off our array of known images, creating a new array of images found on our smoke list.
    # effectively comparing the two, and removing images we don't know
    # smoke_images_known, unless already defined, contains a list of all possible images, so this is important
    images_you_know = UserVars.smoke_images_known.select { |image| smoke_list.any? { |image_and_mastery| image_and_mastery.include?(image) } }
    # smoke_images_known, unless already defined, contains a list of all possible images, so this is important
    UserVars.smoke_images_known = images_you_know
    unless (images - images_you_know).empty? # skip if we haven't asked to smoke any images we don't know
      DRC.message("Removing images you do not know: #{(images - images_you_know).join(' ')}") # prints out a string representing the difference between what images we know and what images we wanted to smoke
      images -= (images - images_you_know) # creates an array of images we don't know, and removes them from our list of images we were hoping to smoke
    end
    # Here we might want to just smoke a curated list of images, regardless of whether we've mastered one or more
    # TODO: support for non-halfling mastery?
    return images unless @smoke_settings['clean_list_of_mastered'] && DRStats.race == 'Halfling'

    # Here we're using the originally generated list like a hash
    images_mastered = smoke_list
                      .select { |image_and_mastery| image_and_mastery.include?('master*') } # selecting only those images we've fully mastered
                      .join(' ') # making a string of image names, dashes, and 'master*'
                      .split # creating a new array with all of those items as elements
                      .reject { |item| item =~ /-|master*/ } # removing the dashes and 'master*' elements, leaving us with just an array of images we've mastered
                      .select { |image| images.include?(image) } # then comparing our original images list to the list of mastered images, and removing any matches.
    DRC.message("Removing already mastered images: #{images_mastered.join(' ')}") unless images_mastered.empty? # images_mastered here means images from our variable 'images' that we sent this method
    UserVars.smoke_images_mastered |= images_mastered # here we're adding any mastered images we found on our list of mastered to our uservar, but only if they're not already present.
    images - UserVars.smoke_images_mastered # Finally, we return our original list minus any images we've mastered.
  end
end

before_dying do
  Flags.delete('new-cig')
end

Smoke.new
