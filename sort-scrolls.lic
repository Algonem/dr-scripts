=begin
  Documentation: https://elanthipedia.play.net/Lich_script_repository#sort-scrolls
=end

custom_require.call(%w[common common-items])

class ScrollSorter

  def initialize
    @settings = get_settings
    @default_container = @settings.default_container
    @stacker = @settings.scroll_sorter['stacker']
    @stacker_container = @settings.scroll_sorter['stacker_container']
    @custom_nouns = @settings.scroll_sorter['scroll_nouns']
    @scroll_nouns = get_data('items').scroll_nouns + @custom_nouns
    @all_spells = get_data('spells')['spell_data']

    arg_definitions =
      [
        [
          { name: 'container', regex: /\w+/, optional: true, description: 'The container to collect scrolls from' }
        ],

        [
          { name: 'find', regex: /find/i },
          { name: 'spell', regex: /\w+/i, variable: true, description: 'Name of spell to find' }
        ]
      ]

    args = parse_args(arg_definitions)
    @default_container = args.container ? args.container : @default_container
    @cases = populate_cases

    if args.find
      find_spell(args.spell)
    else
      sort_scrolls
    end
    DRCI.close_container\?(@stacker_container) if @settings.scroll_sorter['close_container']
  end

  def populate_cases
    c = Array.new
    DRCI.open_container\?(@stacker_container)
    DRC.bput("inv #{@stacker_container}", /^Inside.+you see:/)

    loop do
      line = get
      if line.include?(@stacker)
        /labeled "(.*)"/ =~ line
        guild = Regexp.last_match(1).to_s
        c << guild
      end
      break if line.include?('INVENTORY HELP')
    end
    return c
  end

  def unknown
    DRC.message("Spell not found.  Either a new spell was released and it hasn't been added to the script yet, or you misspelled the spell you're searching for.")
    exit
  end

  def find_scrolls(container)
    x = Array.new
    DRC.bput("inv #{container}", /^Inside.+you see:/)

    loop do
      line = get
      @scroll_nouns.each do |n|
        x << n if line =~ / #{n}/
      end
      break if line.include?('INVENTORY HELP')
    end
    x
  end

  def get_scroll(scroll)
    case DRC.bput("get #{scroll} in my #{@default_container}", /You get/, /What were you referring/)
    when /What were you referring/
      DRC.message("  Can't find #{scroll} in your #{@default_container}!")
      return false
    end
    return true
  end

  def check_scroll(scroll)
    case DRC.bput("look my #{scroll}", /It is labeled "(.*)\."/, /Illustrations of complex/)
    when /Illustrations of complex/
      DRC.message('Not labeled yet!')
      /of the (.*) spell/ =~ DRC.bput("read my #{scroll}", 'The .* contains a complete description of the .* spell')
      spell = Regexp.last_match(1)
      return @all_spells[spell]['guild']
    when /It is labeled "(.*)\."/
      spell = Regexp.last_match(1).to_s
      return @all_spells[spell]['guild']
    end
    return nil
  end

  def find_case(guild)
    @cases.each{ |c| return $ORDINALS[@cases.index(c)] if c.include?(guild) }
  end

  def stack_scroll(scroll, guild)
    if guild == 'Analogous'
      DRC.message("Analogous pattern scroll, dropping it.")
      DRC.bput("drop my #{scroll}", /You drop/)
      return
    end
    ord = find_case(guild)
    DRC.bput("get #{ord} #{@stacker} in my #{@stacker_container}", /You get/)
    case DRC.bput("push my #{@stacker} with my #{scroll}", /you find room in a matching section/, /flip to an empty section/, /you realize there's no more room/, /you need to open the #{@stacker.split.last} first/)
    when /you find room in a matching section/, /flip to an empty section/
      stow_and_refactor_cases(guild)
    when /you need to open the #{@stacker.split.last} first/
      DRC.bput("open my #{@stacker}", /You open your #{@stacker.split.last} to the first section/)
      stow_and_refactor_cases(guild)
      stack_scroll(scroll, guild)
    when /you realize there's no more room/
      stow_and_refactor_cases(guild)
      stack_scroll(scroll, "Extras")
    end
  end

  def stow_and_refactor_cases(guild)
    DRC.bput("put my #{@stacker} in my #{@stacker_container}", /You put your/)
    @cases.delete(guild)
    @cases.unshift(guild)
  end

  def sort_scrolls
    scrolls = find_scrolls(@default_container)
    scrolls.each do |s|
      next unless get_scroll(s)
      guild = check_scroll(s)
      unknown if guild.nil?
      stack_scroll(s, guild)
    end
  end

  def find_spell(name)
    guild = @ALL_SPELLS.select{ |s,g| s =~ /#{name}/i }.flatten[1]
    unknown if guild.nil?
    ord = find_case(guild)
    DRC.bput("get #{ord} #{@stacker} in my #{@stacker_container}", /You get/)
    spells = Array.new
    start = Time.now
    DRC.bput("flip my #{@stacker}", /You flip through the/)

    loop do
      line = get?
      break if (Time.now-start) > 2
      case line
      when /The (.+) section/
        spells.push(Regexp.last_match(1))
      when /Section \d+ is empty/
        spells.push('BlankSection')
      end
    end
    num = spells.index{ |i| i =~ /#{name}/i }
    if num.nil?
      DRC.message("You have no copies of #{name}!")
    else
      DRC.bput("open my #{@stacker}", /You open your/, /is already open/)
      num.times{ DRC.bput("turn my #{@stacker}", /You turn to/, /You've reached the end/) }
      DRC.bput("pull my #{@stacker}", /This was the last copy/, /Carefully, you remove a copy/)
    end
    DRC.bput("put my #{@stacker} in my #{@stacker_container}", /You put your/)
  end
end

ScrollSorter.new
