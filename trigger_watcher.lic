####################################################################################################
# =exec - "execute" - Execute a script
#   =exec <script> <arguments>
# =execw - "execute wait" - Execute script and wait for it to end
#   =execw <script> <arguments>
# =eval = "evaluate as code" - Evaluate the response as Lich/Ruby code
#   =eval DRC.message("Test message")
# =uvar - "user variable" - Set or delete a user variable based on a trigger
#   =uvar set <VarName> <value>
#   =uvar delete <VarName>
#   - (Reference a user variable in a trigger response via $<UserVarName>)
# =logf - "log file" - log to a file in the Lich file tree
#   =logf <FileName> <Text to log>
# =logw - "log window" - log to a window in the FE
#   =logw <WindowName> <Text to log>
# =pause - Pause the specified amount of time
#   =pause 10
# =if/=elsif/=else - Allows if/eslif/else functionality in responses.
#   =if {3 > 2} {DRC.message("Message")} =elsif {2 < 3} {fput("hello")} =else {fput("ELSE")}
####################################################################################################

custom_require.call(%w[events common])

no_pause_all
no_kill_all

# When trigger command =exec has been used. Executes a specified script.
def execute_script(name, args = [], flags = {})
  verify_script(name)
  echo "Starting script #{name}, don't wait to complete" if $debug_mode_tw
  waitrt?
  start_script(name, args.map { |arg| arg =~ /\s/ ? "\"#{arg}\"" : arg }, flags)
end

# When trigger command =execw has been used. Executes a specified script and waits until complete.
def execute_script_wait(name, args = [])
  verify_script(name)
  echo "Starting script #{name}, wait to complete" if $debug_mode_tw
  waitrt?
  DRC.wait_for_script_to_complete(name, args)
end

# When trigger command =uvar has been used
#   set - set or update a UserVar
#   delete - delete an existing UserVar
#   Note: access a UserVar via $<UserVarName> in any trigger response
def execute_uservar(data)
  if data[0] =~ /^set\b/i
    echo "=uvar SET" if $debug_mode_tw
    start_script('vars', ['set', data[1], '=', data[2..-1].join(' ')])
  elsif data[0] =~ /^delete\b/i
    echo "=uvar DELETE" if $debug_mode_tw
    start_script('vars', ['delete', data.drop(1)])
  end
end

# When trigger command =logf has been used. Logs to a file of specified name.
def execute_logf(data)
  echo "Logging to file name #{data[0]}" if $debug_mode_tw
  open("#{data[0]}.txt", 'a') do |f|
    f.puts "#{Time.now.strftime("%Y-%m-%d %I:%M%P")} #{data[1..-1].join(' ')}"
  end
  DRC.message("  Logged to file name: #{data[0]}")
end

# When trigger command =logw has been used. Logs to a window of specified name. Creates window
# if it doesn't exist.
def execute_logw(data)
  echo "Logging to window #{data[0]}" if $debug_mode_tw
  DRC.log_window(data[1..-1].join(' '), data[0], true, true, false)
end

# When trigger command =pause has been used. Pauses the specified amount of time.
def execute_pause(data)
  echo "Pausing #{data[0]} seconds" if $debug_mode_tw
  pause data[0].to_i
end

# When trigger command =if starts the response line. Also parses =elsif and =else.
# Allows multiple inputs for each if/elsif/else.
def execute_if(data)
  echo "Recognized if block" if $debug_mode_tw
  # Split at each =if/elsif/else, reject empty array elements, strip whitespace from each element
  new_data = data.split(/=(?=if|elsif|else)/).reject(&:empty?).collect(&:strip)

  # Break our if/elsif/else data apart for parsing
  if_data = new_data.select { |n| n =~ /^if/ }
                    .map { |n| n.gsub(/^if/, '')}
                    .collect(&:strip)
  elsif_data = new_data.select { |n| n =~ /^elsif/ }
                    .map { |n| n.gsub(/^elsif/, '')}
                    .collect(&:strip)
  else_data = new_data.select { |n| n =~ /^else/ }
                    .map { |n| n.gsub(/^else/, '')}
                    .collect(&:strip)

  echo "if data: #{if_data}" if $debug_mode_tw          # One if, should be array with 1 element, if to check, then response(s)
  echo "elsif data: #{elsif_data}" if $debug_mode_tw    # Could be any number of elsif, array with multiple elements, elsif to check, then response(s)
  echo "else data: #{else_data}" if $debug_mode_tw      # One else, array with single element, only response(s)

  if_elements = if_data[0].scan(/\{(.*?)\}/)
  if_break_out = false

  # Parse if elements. If true, set break out boolean and don't continue to elsif or else.
  if eval(if_elements[0][0])
    echo "Entered if block" if $debug_mode_tw
    if_elements = if_data[0].scan(/\{(.*?)\}/)
    if_elements.drop(1).each do |val|
      waitrt?
      eval(val[0])
    end
    if_break_out = true
  end

  # Parse elsif elements, with a check first for break out if our if parsing was true.
  unless if_break_out
    if elsif_data
      echo "Entered elsif block" if $debug_mode_tw
      elsif_data.each do |val|
        elsif_elements = val.scan(/\{(.*?)\}/)
        unless if_break_out
          if eval(elsif_elements[0][0].to_s)
            if_break_out = true
            elsif_elements.drop(1).each do |val|
              waitrt?
              eval(val[0])
            end
          end
        end
      end
    end
  end

  # Parse else elements, with a check first for break out of our if or elsif parsing was true.
  unless if_break_out
    if else_data
      echo "Entered else block" if $debug_mode_tw
      else_elements = else_data[0].scan(/\{(.*?)\}/)
      else_elements.each do |val|
        waitrt?
        eval(val[0])
      end
    end
  end
end

# When trigger command =eval has been used. Evaluates the response as Lich/Ruby code.
def execute_eval(data)
  echo "Evaluate as code: #{data}" if $debug_mode_tw
  waitrt?
  eval(data)
end

# Load our trigger(s) and response(s) from yaml file base-triggers.yaml.
# Parse each of them and set a Flag based on the trigger.
data = get_data('triggers').to_h
data.each do | name, values |
  echo "Trigger name:  #{name}" if $debug_mode_tw
  echo "Triggers are:  #{values['triggers']}" if $debug_mode_tw
  echo "Responses are: #{values['responses']}" if $debug_mode_tw

  Flags.add(name.to_s, *values['triggers'])
end

# Primary trigger monitoring block. Keep script persistent. Monitor for Flags.
# Did we trigger? If so, send the responses. Reset the flag for next trigger.
until script.gets.nil?
  data.each do | name, values |
    if Flags[name.to_s]
      # echo "Triggered: #{name.to_s}"
      # echo "Trigger text is: #{values['triggers'].first}"
      # echo "Flag is: #{Flags[name.to_s]}"
      # echo "Matchers are: #{Flags.matchers[name.to_s]}"
      # echo "Matchdata for flag #{name.to_s} is: #{Flags.history[name.to_s][0][1]}"
      # echo "Number of elements in history: #{Flags.history[name.to_s].count}"
      # echo "All history is: #{Flags.history}"
      # echo "Flags are: #{Flags.flags}"
      # echo "History for flag #{name.to_s} is: #{Flags.read_matches(name.to_s)}"
      # echo "Is history array cleared? #{Flags.history[name.to_s]}"

      responses = values['responses'].to_a

      # Below we'll look for both regex and UserVar subsitutions in trigger responses,
      # and substitute appropriately if so.
      num_subs = responses.join(' ').scan(/\$(\d)/)
      uvar_subs = responses.join(' ').scan(/\$(\w+\b)/)

      # Process regex substitutions
      if num_subs
        echo "Recognized regex variable subsitutions" if $debug_mode_tw
        num_subs.each do |num|
          responses.map { |string| string.gsub!(/\$#{num.first}\b/, Flags[name.to_s][num.first.to_i]) }
        end
      end

      # Process UserVar substitutions
      if uvar_subs
        echo "Recognized UserVar variable subsititions" if $debug_mode_tw
        uvar_subs.each do |uvar|
          var_value = eval("UserVars." + "#{uvar[0].to_s}")
          unless var_value == nil
            responses.map { |string| string.gsub!(/\$#{uvar[0].to_s}\b/, "#{var_value.to_s}") }
          else
            DRC.message("  Warning, User Variable #{uvar[0]} is not set, but your trigger is attempting to use it.")
          end
        end
      end

      # Send our trigger responses. Parse any trigger commands.
      responses.each do | string |
        waitrt?
        if string =~ /^=exec\b/i
          echo "=exec trigger response" if $debug_mode_tw
          exec_script = string.gsub('=exec', '').split
          execute_script(exec_script[0], exec_script.drop(1))
        elsif string =~ /^=execw\b/i
          echo "=execw trigger response" if $debug_mode_tw
          exec_script = string.gsub('=execw', '').split
          execute_script_wait(exec_script[0], exec_script.drop(1))
        elsif string =~ /^=uvar\b/i
          echo "=uvar trigger response" if $debug_mode_tw
          exec_uvar = string.gsub('=uvar', '').split
          execute_uservar(exec_uvar)
        elsif string =~ /^=logf\b/i
          echo "=logf trigger response" if $debug_mode_tw
          exec_logf = string.gsub('=logf', '').split
          execute_logf(exec_logf)
        elsif string =~ /^=logw\b/i
          echo "=logw trigger response" if $debug_mode_tw
          exec_logw = string.gsub('=logw', '').split
          execute_logw(exec_logw)
        elsif string =~ /^=pause\b/i
          echo "=pause trigger response" if $debug_mode_tw
          exec_pause = string.gsub('=pause', '').split
          execute_pause(exec_pause)
        elsif string =~ /^=if\b/i
          echo "=if/elsif/else trigger response" if $debug_mode_tw
          execute_if(string)
        elsif string =~ /^=eval\b/i
          echo "=eval trigger response" if $debug_mode_tw
          exec_eval = string.gsub('=eval', '').strip
          execute_eval(exec_eval)
        else
          echo "regular trigger response (default fput)" if $debug_mode_tw
          fput(string)
        end
      end

      # Reset flag, ready for next occurrence of trigger
      Flags.reset(name.to_s)
    end
  end
end
