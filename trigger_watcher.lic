####################################################################################################
# =exec - "execute" - Execute a script
#   =exec <script> <arguments>
# =execw - "execute wait" - Execute script and wait for it to end
#   =execw <script> <arguments>
# =uvar - "user variable" - Set or delete a user variable based on a trigger
#   =uvar set <VarName> <value>
#   =uvar delete <VarName>
#   - (Reference a user variable in a trigger response via $<VarName>)
# =logf - "log file" - log to a file in the Lich file tree
#   =logf <FileName> <Text to log>
# =logw - "log window" - log to a window in the FE
#   =logw <WindowName> <Text to log>
####################################################################################################

custom_require.call(%w[events common])

no_pause_all
no_kill_all

# When trigger command =exec has been used. Executes a specified script.
def execute_script(name, args = [], flags = {})
  echo "Calling script: #{name}"
  verify_script(name)
  waitrt?
  start_script(name, args.map { |arg| arg =~ /\s/ ? "\"#{arg}\"" : arg }, flags)
end

# When trigger command =execw has been used. Executes a specified script and waits until complete.
def execute_script_wait(name, args = [])
  echo "Calling script: #{name} and waiting"
  verify_script(name)
  waitrt?
  DRC.wait_for_script_to_complete(name, args)
end

# When trigger command =uvar has been used
#   set - set or update a UserVar
#   delete - delete an existing UserVar
#   Note: access a UserVar via $<UserVarName> in any trigger response
def execute_uservar(data)
  echo "In execute uservar"
  echo "data is: #{data}"
  if data[0] =~ /^set\b/i
    echo "In set"
    start_script('vars', ['set', data[1], '=', data[2..-1].join(' ')])
  elsif data[0] =~ /^delete\b/i
    echo "In delete"
    start_script('vars', ['delete', data.drop(1)])
  end
end

# When trigger command =logf has been used. Logs to a file of specified name.
def execute_logf(data)
  echo data
  echo "In execute logf"
  echo data[1..-1].join(' ')

  open("#{data[0]}.txt", 'a') do |f|
    f.puts "#{Time.now.strftime("%Y-%m-%d %I:%M%P")} #{data[1..-1].join(' ')}"
  end
  DRC.message("  Logged to file name: #{data[0]}")
end

def execute_logw(data)
  echo data
  echo "In execute logw"
  echo data[1..-1].join(' ')
  DRC.log_window(data[1..-1].join(' '), data[0], true, true, false)
end

def execute_pause(data)
  echo "In execute pause"
  echo data
  echo "Pausing #{data[0]}"
  pause data[0].to_i
  echo "Done pausing"
end

def execute_if(data)
  echo "In execute if"
  echo data

  # Split at each equals sign, reject empty array elements, strip whitespace from each element
  new_data = data.split(/=/).reject(&:empty?).collect(&:strip)

  # Break our if/elsif/else data apart
  if_data = new_data.select { |n| n =~ /^if/ }
                    .map { |n| n.gsub(/^if/, '')}
                    .collect(&:strip)
  elsif_data = new_data.select { |n| n =~ /^elsif/ }
                    .map { |n| n.gsub(/^elsif/, '')}
                    .collect(&:strip)
  else_data = new_data.select { |n| n =~ /^else/ }
                    .map { |n| n.gsub(/^else/, '')}
                    .collect(&:strip)

  echo "if data: #{if_data}"        # One if, should be array with 1 element, if to check, then responses
  echo "elsif data: #{elsif_data}"    # Could be any number of elsif, array with multiple elements, elsif to check, then responses
  echo "else data: #{else_data}"     # One else, array with single element, no else check, only responses

  if_check = if_data[0].scan(/\{(.*?)\}/).flatten.first

  echo "if_check: #{if_check}"

  if_break_out = false

  if eval(if_check)
    echo "it's true"


    if_break_out = true
  end

  unless if_break_out
    if elsif_data
      echo "In elsif"
      echo "inside elsif unless"
      elsif_data.each do |val|
        echo "inside .each do"
        echo "elsif val is: #{val}"
        elsif_elements = val.scan(/\{(.*?)\}/)
        unless if_break_out
          echo "Inside lowest if_break_out"
          echo "elsif_elements[0][0] is: #{elsif_elements[0][0]}"
          if eval(elsif_elements[0][0].to_s)
            if_break_out = true
            elsif_elements.drop(1).each do |val|
              echo "val is: #{val}"
              eval(val[0])
            end
          end
        end
      end
    end
  end

  unless if_break_out
    if else_data
      echo "In else data"
      else_elements = else_data[0].scan(/\{(.*?)\}/)
      echo else_elements
      else_elements.each do |val|
        echo val
        eval(val[0])
      end
    end
  end
end

# Load our trigger(s) and response(s) from yaml file base-triggers.yaml.
# Parse each of them and set a Flag based on the trigger.
data = get_data('triggers').to_h
data.each do | name, values |
  echo "Trigger name:  #{name}" if $debug_mode_tw
  echo "Triggers are:  #{values['triggers']}" if $debug_mode_tw
  echo "Responses are: #{values['responses']}" if $debug_mode_tw

  Flags.add(name.to_s, *values['triggers'])
end

# Primary trigger monitoring block. Keep script persistent. Monitor for Flags.
# Did we trigger? If so, send the responses. Reset the flag for next trigger.
until script.gets.nil?
  data.each do | name, values |
    if Flags[name.to_s]
      # echo "Triggered: #{name.to_s}"
      # echo "Trigger text is: #{values['triggers'].first}"
      # echo "Flag is: #{Flags[name.to_s]}"
      # echo "Matchers are: #{Flags.matchers[name.to_s]}"
      # echo "Matchers are type #{Flags.matchers[name.to_s].is_a?(Array)}"
      # echo "Matchdata for flag #{name.to_s} is: #{Flags.history[name.to_s][0][1]}"
      # echo "History data type is array? #{Flags.history[name.to_s].is_a?(Array)}"
      # echo "Number of elements in history: #{Flags.history[name.to_s].count}"
      # echo "All history is: #{Flags.history}"
      # echo "Flags are: #{Flags.flags}"
      # echo "History for flag #{name.to_s} is: #{Flags.read_matches(name.to_s)}"
      # echo "Is history array cleared? #{Flags.history[name.to_s]}"

      responses = values['responses'].to_a

      # Below we'll look for both regex and UserVar subsitutions in trigger responses,
      # and substitute appropriately if so.
      num_subs = responses.join(' ').scan(/\$(\d)/)
      echo num_subs

      # Process regex substitutions
      if num_subs
        num_subs.each do |num|
          echo "num is #{num.first}"
          responses.map { |string| string.gsub!(/\$#{num.first}\b/, Flags[name.to_s][num.first.to_i]) }
        end
      end

      echo responses

      uvar_subs = responses.join(' ').scan(/\$(\w+\b)/)
      echo uvar_subs

      # Process UserVar substitutions
      if uvar_subs
        uvar_subs.each do |uvar|
          echo uvar[0]
          var_value = eval("UserVars." + "#{uvar[0].to_s}")
          unless var_value == nil
            responses.map { |string| string.gsub!(/\$#{uvar[0].to_s}\b/, "#{var_value.to_s}") }
          else
            DRC.message("  Warning, User Variable #{uvar[0]} is not set, but your trigger is attempting to use it.")
          end
        end
      end

      # Send our trigger responses. Parse any leading trigger commands.
      responses.each do | string |
        waitrt?
        if string =~ /^=exec\b/i
          echo "Found exec"
          exec_script = string.gsub('=exec', '').split
          echo exec_script[0]
          echo exec_script.drop(1)
          execute_script(exec_script[0], exec_script.drop(1))
        elsif string =~ /^=execw\b/i
          echo "Found exec"
          exec_script = string.gsub('=execw', '').split
          echo exec_script[0]
          echo exec_script.drop(1)
          execute_script_wait(exec_script[0], exec_script.drop(1))
        elsif string =~ /^=uvar\b/i
          echo "Found uvar"
          exec_uvar = string.gsub('=uvar', '').split
          echo exec_uvar
          echo exec_uvar[0]
          echo exec_uvar.drop(1)
          execute_uservar(exec_uvar)
        elsif string =~ /^=logf\b/i
          echo "Found logf"
          exec_logf = string.gsub('=logf', '').split
          echo exec_logf
          echo exec_logf[0]
          echo exec_logf.drop(1)
          execute_logf(exec_logf)
        elsif string =~ /^=logw\b/i
          echo "Found logw"
          exec_logw = string.gsub('=logw', '').split
          echo exec_logw
          echo exec_logw[0]
          echo exec_logw.drop(1)
          execute_logw(exec_logw)
        elsif string =~ /^=pause\b/i
          echo "Found pause"
          exec_pause = string.gsub('=pause', '').split
          echo exec_pause
          echo exec_pause[0]
          echo exec_pause.drop(1)
          execute_pause(exec_pause)
        elsif string =~ /^=if\b/i
          echo "Found if"
          # exec_if = string.gsub('=if', '')
          echo string
          execute_if(string)
        else
          fput(string)
        end
      end

      # Reset flag, ready for next occurrence of trigger
      Flags.reset(name.to_s)
    end
  end
end
