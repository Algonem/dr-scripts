#   Documentation: https://elanthipedia.play.net/Lich_script_repository#restock

custom_require.call(%w[common common-items common-travel common-money])

class HerbStock
  def initialize
    arg_definitions = [
      [
        { name: 'town', regex: $HOMETOWN_REGEX, optional: true, description: 'Town to restock in' }
      ]
    ]
    args = parse_args(arg_definitions)

    @settings = get_settings
    @hometown = DRC.get_town_name(args.town || @settings.hometown)
    amount, denom = @settings.sell_loot_money_on_hand.split(' ')
    @keep_copper = DRCM.convert_to_copper(amount, denom)
    @remedy_container = @settings.remedy_container

    if @hometown == 'Riverhaven' && DRSkill.getrank('Athletics') > 140
      @hometown = 'Crossing'
    end

    if(@hometown != 'Crossing' && @hometown != 'Shard')
      echo 'Only Crossing, Riverhaven (with over 140 Athletics), and Shard hometowns supported. You may provide Crossing or Shard as an argument to override your hometown.'
      exit
    end

    @settings.storage_containers.each { |container| fput("open my #{container}") }

    herbs = get_data('healingherbs').herb_stocks[@hometown]

    herbsWithLocations = herbs.select { |k| k['location'] } # find any herbs that have a specific location defined

    herbs -= herbsWithLocations

    restock_items(herbs, @hometown) # restock herbs that do not have a specific location

    herbsWithLocations.group_by { |v| v['location'] }
      .each do |location, herbsToStock|

        if location == "Riverhaven" && DRSkill.getrank('Athletics') < 150
          next
        end

        restock_items(herbsToStock, location)
      end

  end

  def restock_items(item_list, town)
    items_to_restock = []
    coin_needed = 0

    item_list.each do |item|
      remaining = count_combinable_item(item['name'])
      next unless remaining < item['quantity']
      num_needed = item['quantity'] - remaining
      buy_num = (num_needed / item['size'].to_f).ceil
      coin_needed += buy_num * item['price']
      item['buy_num'] = buy_num
      items_to_restock.push(item)
    end

    if items_to_restock.length == 0
      echo "*** No Herbs Needed from #{town} ***"
      return
    end

    DRCM.ensure_copper_on_hand(coin_needed, @settings, town)

    items_to_restock.each do |item|
      item['buy_num'].times do
        DRCI.stow_hands
        DRCI.get_item?(item['name'], @remedy_container) if item['stackable']
        DRCT.buy_item(item['room'], item['name'])
        split_name = item['name'].split(' ')
        DRC.bput("combine #{split_name.last} with #{split_name.last}", 'You combine', 'You must be holding') if item['stackable']
        [DRC.left_hand, DRC.right_hand].compact.each { DRCI.put_away_item?(item['name'], @remedy_container) }
      end
    end

    DRCM.deposit_coins(@keep_copper, @settings, town)
  end

  def count_combinable_item(item)
    count = 0
    $ORDINALS.each do |ordinal|
      count_msg = DRC.bput("count my #{ordinal} #{item}", 'I could not find what you were referring to.', 'tell you much of anything.', 'There is only one part', 'There are (.+) parts left of the ', 'You count out (.+) pieces ')
      case count_msg
      when 'I could not find what you were referring to.'
        break
      when 'tell you much of anything.'
        echo "#{item} is marked as stackable but is not!"
        break
      when 'There is only one part'
        count += 1
      else
        count_txt = count_msg.match(/There \w+ (.+) \w+ left of the / || /You count \w+ (.+) \w+ /).captures.first.tr('-', ' ')
        count += DRC.text2num(count_txt)
      end
      waitrt?
    end
    count
  end
end

HerbStock.new