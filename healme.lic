=begin
  Documentation: https://elanthipedia.play.net/Lich_script_repository#healme
=end

custom_require.call(%w[common common-arcana common-healing events spellmonitor])

class HealMe
  include DRC
  include DRCA
  include DRCH

  def initialize
    @settings = get_settings
    arg_definitions = [
      [
        { name: 'debug', regex: /debug/i, optional: true, description: 'Enable debug output' },
        { name: 'keep', regex: /^[\w\s,]+$/i, variable: true, optional: true, description: 'Comma separated list of wounds to keep. Example: "right arm, chest, back"' }
      ]
    ]
    args = parse_args(arg_definitions)
    $debug_mode_hm = UserVars.healme_debug || args.debug
    @spells = load_healing_waggle_set
    @body_parts_not_to_heal = args.keep.split(',').map(&:strip) || []
    add_health_flags
    heal_self
  end

  # The original version of the 'healme' script used
  # the 'empath_healing:' setting to configure the spells to cast.
  # Later, the script added support for waggle sets.
  # This method checks for how the player has specified their
  # healing spells, using the waggle set by default if defined.
  # Returns the spell data in a waggle format, regardless the configuration used.
  def load_healing_waggle_set
    waggle_set = @settings.waggle_sets['healing']
    if empty?(waggle_set) || empty?(@settings.empath_healing)
      DRC.message("Neither waggle set 'healing' nor setting 'empath_healing:' are configured")
      DRC.message("See https://elanthipedia.play.net/Lich_script_development#healme")
      exit
    end
    if waggle_set
      echo "Using 'healing' waggle set to define healing spells" if $debug_mode_hm
    else
      echo "Using empath_healing setting to define healing spells" if $debug_mode_hm
      # The 'empath_healing' setting is a map where the keys are spell abbreviations
      # and the values are a list of mana to use.
      # For example, definition for Heal Wounds spell with prep of 5 and cambrinth of 10:
      #   empath_healing:
      #     'HW':
      #     - 5
      #     - 10
      waggle_set = {}
      spell_data = get_data('spells')['spell_data']
      @settings.empath_healing.each do |abbrev, manas|
        spells = spell_data.select { |name, data| data['abbrev'].downcase == abbrev.downcase }
        name, data = spells.to_a.first.dup
        # Modify the base spell data with the user's config.
        # The first value in the manas list is the prep, rest are for cambrinth.
        data['mana'] = manas.first if manas.length > 0
        data['cambrinth'] = manas[1..-1] if manas.length > 1
        waggle_set[name] = data
      end
    end
    echo "Healing spells: #{waggle_set}" if $debug_mode_hm
    waggle_set
  end

  # This method triages your wounds and heals the most severe first.
  # After a round of healing, it rechecks your wounds to determine
  # which are now the most severe, and then heals them. In this manner,
  # you're always trying to heal the most severe wounds in the moment.
  def heal_self
    loop do
      echo 'Checking health' if $debug_mode_hm
      # Using these variable names to not conflict with
      # implicit 'health' variable that tells your vitality.
      self_health = get_self_health
      perc_health = get_perc_health
      break unless wounds_to_heal?(self_health, perc_health)
      reset_health_flags
      attend_vitals
      flush_poisons if self_health['poisoned']
      cure_diseases if self_health['diseased']
      # Address the most severe wounds for a given category each loop iteration.
      # This heals the most severe bleeders first, then restarts the loop.
      # If there are more bleeders, it heals the next severity level, then restarts the loop.
      # This continues until no more bleeders and then it begins to triage the next wound types.
      # This ensures minor scratches aren't attended to before bleeders, lodged items, parasites, etc.
      if self_health['bleeders'].length > 0
        heal_wounds(self_health['bleeders'])
      elsif self_health['lodged'].length > 0
        tend_wounds(self_health['lodged'])
      elsif self_health['parasites'].length > 0
        tend_wounds(self_health['parasites'])
      elsif perc_health['wounds'].length > 0
        heal_wounds(perc_health['wounds'])
      elsif self_health['wounds'].length > 0
        heal_wounds(self_health['wounds'])
      elsif health < 100
        heal_vitality
      end
    end
  end

  # Get wounds inferred from HEALTH command.
  def get_self_health
    echo 'Checking for visible wounds, bleeders, parasites, and lodged items' if $debug_mode_hm
    self_health = DRCH.check_health
    # Exclude bleeders that are '(tended)' because
    # they aren't causing immediate loss of vitality
    # and, more technically, once the body part is
    # healed the wound will still be listed in HEALTH
    # as '(tended)' giving the impression you have a bleeder
    # when in reality you don't. We have to wait for the
    # bandages to fall off or removed explicitly in order
    # to no longer see a bleeder in the HEALTH output.
    # Without this workaround, the script loops repeatedly
    # trying to heal a body part that's not injured.
    self_health['bleeders'].each do |severity, wounds|
      wounds.select! { |wound| wound.bleeding_rate != '(tended)' }
    end
    # Now, remove any keys from the map if no wounds left after filtering.
    self_health['bleeders'].select! { |severity, wounds| wounds.length > 0 }
    remove_wounds_to_keep(self_health)
  end

  # Get wounds inferred from PERCEIVE HEALTH SELF.
  def get_perc_health
    return if @settings.permashocked
    echo 'Perceiving internal and external wounds and scars' if $debug_mode_hm
    remove_wounds_to_keep(DRCH.perceive_health)
  end

  # Takes a pulse on vitality then takes action accordingly.
  # Designed to be called frequently so that low vitality
  # and bleeding can be addressed immediately.
  def attend_vitals
    heal_vitality if health < [50, @settings.health_threshold].max
    stop_bleeding if bleeding?
    cast_regenerate if @spells['Regenerate']
    cast_heal if @spells['Heal']
  end

  # Returns wounds list without the ones
  # that are for body parts we want to keep.
  def remove_wounds_to_keep(wounds)
    echo "All wounds: #{wounds}" if $debug_mode_hm
    echo "Wounds to keep: #{@body_parts_not_to_heal}" if $debug_mode_hm
    wounds = wounds.select do |wound|
      !@body_parts_not_to_heal.any? do |body_part|
        body_part.downcase == wound.body_part.downcase
      end
    end
    echo "Wounds to heal: #{wounds}" if $debug_mode_hm
    wounds
  end

  # Determines if there are any wounds, poisons, etc to heal.
  def wounds_to_heal?(observed_health, perceived_health)
    wounds_to_heal = (
      !empty?(perceived_health['wounds']) ||
      !empty?(observed_health['wounds']) ||
      !empty?(observed_health['bleeders']) ||
      !empty?(observed_health['parasites']) ||
      !empty?(observed_health['lodged']) ||
      observed_health['poisoned'] ||
      observed_health['diseased'] ||
      health < 100
    )
    echo "Wounds to heal? #{wounds_to_heal}" if $debug_mode_hm
    wounds_to_heal
  end

  # If your 'healing' waggle set contains 'Vitality Healing' spell
  # then casts it to try and restore vitality.
  def heal_vitality
    cast_spell_or_warn('Vitality Healing', "You're vitality is low!")
  end

  # If your 'healing' waggle set contains 'Flush Poisons' spell
  # then casts it to try and remove poisons.
  def flush_poisons
    cast_spell_or_warn('Flush Poisons', "You're poisoned!")
  end

  # If your 'healing' waggle set contains 'Cure Disease' spell
  # then casts it to try and cure diseases.
  def cure_diseases
    cast_spell_or_warn('Cure Disease', "You're diseased!")
  end

  # If your 'healing' waggle set contains 'Regenerate' spell
  # then casts it to boost your healing rate.
  def cast_regenerate
    cast_spell('Regenerate')
  end

  # If your 'healing' waggle set contains 'Heal' spell
  # then casts it to boost your healing rate.
  def cast_heal
    cast_spell('Heal')
  end

  # Heal all the wounds of the highest severity, then returns
  # so that the main healing loop can triage the next wounds to heal.
  # The 'wounds' argument is a map whose keys are severity numbers (1,2,3...)
  # and the values are a list of wounds. So this only heals the wounds
  # for the map key that is the highest severity at the time.
  def heal_wounds(wounds)
    # While iterating the wounds to heal,
    # track if any body parts become completely healed
    # so that we can avoid unnecessary spell casting.
    # For example, a cast to heal an external chest wound
    # could spill over and fully heal the internal wound, too.
    # If the internal chest wound is in the wounds-to-heal list
    # we'll waste time/mana overhealing an already healed wound.
    # This is designed to only optimize healing the list of wounds
    # given to this method with the understanding that your
    # health and any remaining wounds will be re-assesed
    # in the loop that called 'heal_wounds' to begin with.
    # Also means that if some other cause reintroduces a wound
    # then we won't mistakenly consider it still healed.
    healed_body_parts = {
      'internal' => {
        'wounds' => [],
        'scars' => []
      },
      'external' => {
        'wounds' => [],
        'scars' => []
      }
    }
    wounds.sort_by { |severity, wounds| severity }.reverse.first[1].each do |wound|
      wound_location = wound.internal? ? 'internal' : 'external'
      wound_type = wound.scar? ? 'scars' : 'wounds'
      # Before we try to heal a wound, check if it's already been healed either
      # from a previous, potent cast or from heal over time spells like Heal or Regenerate.
      ['internal', 'external'].each { |x| ['wounds', 'scars'].each { |y| healed_body_parts[x][y] << wound.body_part if Flags["hm-#{x}-#{y}-healed"] } }
      next if healed_body_parts[wound_location][wound_type].include?(wound.body_part)
      heal_wound(wound)
      attend_vitals
    end
  end

  # Casts either Heal Wounds or Heal Scars for the given wound.
  # If it's an internal wound then casts <spell> reverse.
  def heal_wound(wound)
    echo "Healing wound: #{wound.inspect}" if $debug_mode_hm
    stop_bleeding(wound) if wound.bleeding?
    spell_name = wound.scar? ? 'Heal Scars' : 'Heal Wounds'
    # If an internal wound then focus healing power there,
    # with any remaining healing power going to the external wound.
    # If an external wound then the opposite will occur.
    # Healing power focused on the external wound and any remaining
    # will be directed to the internal wound.
    spell_location = wound.internal? ? 'reverse' : ''
    @spells[spell_name]['cast'] = "cast #{wound.body_part} #{spell_location}"
    cast_spell_or_warn(spell_name)
  end

  # Similar to 'heal_wounds' except instead of casting a spell on the wound
  # this method tends the wound to remove parasites or lodged items.
  # This method is not intended for bleeders, use `heal_wound` method for those.
  def tend_wounds(wounds)
    wounds.sort_by { |severity, wounds| severity }.reverse.first[1].each do |wound|
      tend_wound(wound)
      attend_vitals
    end
  end

  # For tending bleeders, dislodging ammo, or removing parasites.
  def tend_wound(wound)
    echo "Tending wound: #{wound.inspect}" if $debug_mode_hm
    DRCH.bind_wound(wound.body_part)
  end

  # If your 'healing' waggle set contains 'Blood Staunching' spell
  # then casts it to stop blood loss.
  # If given a wound that is a simple enough bleeder, tends it, too.
  def stop_bleeding(wound = nil)
    DRCH.bind_wound(wound.body_part) if wound_tendable?(wound)
    cast_spell_or_warn('Blood Staunching', "You're bleeding!") if bleeding?
  end

  # If the wound is an easy to tend external bleeder, then tend it.
  # May want this to be configurable, also to attempt to tend
  # more severe wounds based on First Aid skill.
  def wound_tendable?(wound)
    return false unless wound
    tendable = wound.bleeding? && !wound.internal? && DRCH.skilled_to_tend_wound?(wound.severity)
    echo "Wound tendable? #{tendable} #{wound.inspect}" if $debug_mode_hm
    tendable
  end

  # If the spell is configured in your 'healing' waggle set then casts it.
  # Otherwise displays a warning message that you're wounded without ability to heal it.
  def cast_spell_or_warn(spell_name, message = nil)
    if @spells[spell_name]
      cast_spell(spell_name)
    else
      warn_no_spell(spell_name, message)
    end
  end

  # Cast a spell if it's not active.
  def cast_spell(spell_name)
    if DRSpells.active_spells[spell_name]
      echo "Skipping casting spell #{spell_name} because already active" if $debug_mode_hm
    else
      echo "Casting spell: #{spell_name}" if $debug_mode_hm
      DRCA.check_discern(@spells[spell_name], @settings) if @spells[spell_name]['use_auto_mana']
      DRCA.cast_spells({ spell_name: @spells[spell_name] }, @settings)
    end
  end

  def warn_no_spell(spell_name, message = nil)
    DRC.message(message) if message
    DRC.message("The spell '#{spell_name}' is neither configured in the 'healing' waggle set nor 'empath_healing:' setting")
    DRC.message("You may need to seek the help from another healer or remedy")
  end

  def add_health_flags
    ['internal', 'external'].each { |x| ['wounds', 'scars'].each { |y| Flags.add("hm-#{x}-#{y}-healed", "The #{x} #{y} on your (.+) appear completely healed") } }
  end

  def reset_health_flags
    ['internal', 'external'].each { |x| ['wounds', 'scars'].each { |y| Flags.reset("hm-#{x}-#{y}-healed") } }
  end

  # Returns true if the argument is nil or empty.
  def empty?(x)
    x.nil? || x.empty?
  end
end

before_dying do
  ['internal', 'external'].each { |x| ['wounds', 'scars'].each { |y| Flags.delete("hm-#{x}-#{y}-healed") } }
end

HealMe.new
